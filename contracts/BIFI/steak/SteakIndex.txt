// SPDX-License-Identifier: MIT

pragma solidity ^0.6.12;
pragma experimental ABIEncoderV2;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";
import "@openzeppelin/contracts/math/SafeMath.sol";
import "../../interfaces/common/IERC20Extended.sol";
import "../../interfaces/common/IUniswapRouterETH.sol";
import "../../interfaces/common/IUniswapV2Pair.sol";
import "../../interfaces/beefy/IVault.sol";
import "../Common/StratManager.sol";
import "../Common/FeeManager.sol";

contract SteakIndex is StratManager, FeeManager {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    address public butcher;
    address public treasury;

    uint256 public totalAlloc;

    struct SteakCut {
        address want;
        address mooToken;
        address router;
        uint256 balance;
        uint256 alloc;
        uint256 underlying;
    }

    SteakCut[] public cut;

    constructor(
        address _butcher,
        address _want,
        address _mooToken,
        address _router,
        uint256 _alloc,
        address _treasury
    ) public {
        butcher = _butcher;
        treasury = _treasury;
        
        steakCut.push(
            SteakCut({
                want: _want,
                mooToken: _mooToken,
                router: _router,
                balance: 0,
                alloc: _alloc,
                underlying: 0;
            })
        );
    }

    function updateSteakCuts() internal {
        uint256 length = cut.length;
        for (uint256 i = 0; i < length; i++) {
            steakCut[i].underlying = 
                IVault(steakCut[i].mooToken).balance()
                .div(IVault(steakCut[i].mooToken).totalSupply())
                .mul(steakCut[i].balance);
        }
    }

    function deposit(uint256[] calldata amount) external {
        require(msg.sender = butcher, "!Not Butcher");

        for(uint256 i = 0, i < cut.length, i++) {

        }
        underlying.safeTransferFrom(msg.sender, address(this), amount);
    }

    
    function withdraw(uint256[] calldata amount) external {
        require(msg.sender = butcher, "!Not Butcher");

        for(uint256 i = 0, i < steakCuts.length, i++) {
            
        }
        underlying.safeTransferFrom(msg.sender, address(this), amount);
    }

     function rebalance(uint256[] calldata amount) external {
        require(msg.sender = butcher, "!Not Butcher");

        for(uint256 i = 0, i < steakCuts.length, i++) {
            
        }
        underlying.safeTransferFrom(msg.sender, address(this), amount);
    }


}